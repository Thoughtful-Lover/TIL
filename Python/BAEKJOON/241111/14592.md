# 문제 이해
### 14592. 2017 아주대학교 프로그래밍 경시대회 (Small)
* 문제는 Small 데이터와 Large 데이터
* 입력 파일을 다운 받고 5분 이내로 이에 맞는 출력 파일과 소스 코드를 업로드
* Small 데이터 문제를 해결해야 :arge 데이터 입력 파일을 다운 받을 수
* 각 문제의 Small, Large 데이터를 해결하면 점수
* 제출 횟수는 점수를 획득한 문제를 맞기까지 인풋을 다운로드 받은 횟수의 총합
* 점수를 획득하지 못한 문제의 다운로드 횟수는 포함되지 않음
##### 순위
* 해결한 문제 점수의 총합이 높은 참가자가 더 높은 순위를 가짐
* 점수의 총합이 같은 경우, 제출 횟수가 적은 참가자가 더 높은 순위를 가짐
* 점수의 총합과 제출 횟수가 같은 경우, 마지막으로 점수를 획득한 문제의 업로드 시간이 빠른 참가자가 더 높은 순위
### 입력
* 첫 번째 줄에는 참가자의 수 N (1<=N<=3)
* 두 번째 줄부터 N개의 줄에 걸쳐 세 개의 정수
  * 점수, 제출 횟수, 마지막으로 점수를 획득한 문제의 업로드 시간
### 출력
* 1등을 하는 참가자의 번호를 한 줄에 출력
# 문제 구상
* 우선순위에 따라, 점수의 총합, 제출 횟수, 마지막으로 점수를 획득한 문제의 업로드 시간 순으로
# 문제 풀이
```python
# 참가자 수 입력
N = int(input())
# attendants 배열을 2차원으로 만들어서, 점수의 총합, 제출 횟수, 마지막으로 점수를 획득한 문제의 업로드 시간을 각각 평가혀록 함
attendants = [[] for _ in range(3)]
# 각 참가자의 정보를 각각의 배열에 입력
for _ in range(N):
    a, b, c = map(int, input().split())
    attendants[0].append(a)
    attendants[1].append(b)
    attendants[2].append(c)
# 최대 점수를 받은 값이 하나
if attendants[0].count(max(attendants[0])) == 1:
    print(attendants[0].index(max(attendants[0]))+1)
elif attendants[1].count(max(attendants[1])) == 1:
    print(attendants[1].index(max(attendants[1]))+1)
else:
    print(attendants[2].index(max(attendants[2]))+1)
```