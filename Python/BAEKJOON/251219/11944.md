# 문제 이해
### 11944. NN (브론즈 2)
* N을 N번 출력하는 프로그램 작성
* 단, 답이 길어지면 답의 앞 M자리만 출력
### 입력
* 첫 번째 줄에는 N,M이 주어짐
### 출력
* N을 N번 출력
* 만약 답이 길어지면 답의 앞 M자리를 출력
# 문제 구상
* 반복문을 활용해서 출력
* 제약조건으로 M을 넘지 않는 범위 내에서만 출력하도록
# 문제 풀이
### 1차 시도
```python
# N과 M을 각각 입력 받음
N, M = map(int, input().split())
# N과 M 값 중 더 작은 값만큼 반복해서 출력
for _ in range(min(N, M)):
    # 공백 없이 한 줄에 이어서 출력되도록 조건 설정
    print(N, end='')
```
* 출력 초과
* 조건을 잘못 확인
  * 'M자리'를 출력하는 것임
### 2차 시도
```python
# N과 M을 각각 입력 받음
N, M = map(int, input().split())
# N을 N번 출력하는 경우와 M자리만큼 출력하는 경우 중 더 작은 값을 변수 length에 저장
length = min(N*N, M)
# N을 문자열 형태로 바꾸고, 출력할 길이를 N으로 나눈 몫보다 1만큼 크게 만들되, 전체 길이는 length를 넘지 않도록 함
# 이는 M자리수가 N값의 반복의 중간에서 멈출 경우를 대비하는 것임
print(str(N)*(length//N+1)[:length])
```
* TypeError
* 아 이거 슬라이싱이 곱셈 연산보다 먼저 뒷 부분이 적용이 되서 그럼
### 3차 시도
```python
# N과 M을 각각 입력 받음
N, M = map(int, input().split())
# N을 N번 출력하는 경우와 M자리만큼 출력하는 경우 중 더 작은 값을 변수 length에 저장
length = min(N*N, M)
# 추후 처리를 위해 N을 문자열로 바꿔주고
N = str(N)
# 출력할 길이를 N의 길이로 나눈 몫보다 1만큼 크게 만들되, 전체 길이는 length를 넘지 않도록 함
# 이는 M자리수 만큼 출력할 때, N값이 반복되다가 N값의 중간 위치 어딘가에서 출력이 멈추는 경우를 고려함
print((N*(length//len(N)+1))[:length])
```
* 정말 어디가 틀렸는지 감도 안옴
* 저 length//len(N) 이 부분이 문제였던 듯
### n차 시도
```python
# N과 M을 각각 입력 받음
N, M = map(int, input().split())
# N을 N번 출력하는 경우와 M자리만큼 출력하는 경우 중 더 작은 값을 변수 length에 저장
length = min(N*N, M)
# N을 문자열 형태로 바꾸고, 출력할 길이를 N으로 나눈 몫보다 1만큼 크게 만들되, 전체 길이는 length를 넘지 않도록 함
# 이는 M자리수가 N값의 반복의 중간에서 멈출 경우를 대비하는 것임
print((str(N)*N)[:length])
```
* 32,412 KB
* 32 ms
* 뭔가에 씌인 것처럼 잘못된 답으로 달리고 있었음 환기가 필요함