# 문제 이해
### 1952. 달팽이2 (브론즈 1)
* M줄 N칸으로 되어 있는 표 위에, 달팽이 모양으로 선을 그림
* 표의 왼쪽 위 칸에서 시작하여 오른쪽으로 선을 그어가되 더이상 이동할 수 없으면 시계방향으로 선을 꺾음
* 표의 모든 칸이 채워질 때까지, 선을 몇 번 꺾게 될까?
### 입력
* 첫째 줄에 M과 N이 빈 칸을 사이에 두고 주어짐 (2<=M, N<=100)
### 출력
* 첫째 줄에 표의 모든 칸이 채워질 때까지 선이 꺾어지는 횟수를 출력
# 문제 구상
* 델타로 이동하면서 앞의 지역을 이미 방문했거나 범위를 벗어나면 인덱스 값을 증가하되 반복하기 위해서 4로 나눈 나머지를 이용해 줌
# 문제 풀이
### 1차 시도
```python
# 줄과 칸 정보를 입력 받음
M, N = map(int, input().split())
# 선을 표현할 그래프를 정의
graph = [[0]*N for _ in range(M)]
# 시작 위치를 표시
graph[0][0] = 1
# 선을 꺾는 횟수를 저장할 변수 cnt
cnt = 0
# 선의 방향 전환을 담당할 delta, 시계방향으로 꺾게 되므로, 우하좌상 순서
delta = [(0, 1), (1, 0), (0, -1), (-1, 0)]
# 현재 위치를 저장할 변수 y, x
y, x = (0, 0)
# 현재 방향을 저장할 변수 idx
idx = 0
# 방향을 꺾은 여부를 저장할 변수 is_turned
is_turned = False
while True:
    # 다음에 이동할 위치를 ny, nx로 계산
    # 이때 idx를 차례로 증가하는 방식으로 진행할 예정이므로 상하좌우 4가지인 값을 반복해서 사용하도록 4로 나눈 나머지를 활용
    ny, nx = y+delta[idx%4][0], x+delta[idx%4][1]
    # 이동할 위치가 그래프 범위 안에 있고 아직 반복 안 했으면
    if 0<=ny<M and 0<=nx<N and not graph[ny][nx]:
        # 이전 이동에서 방향을 꺾었다면
        if is_turned:
            # cnt 1 증가하고 다시 is_turned 값을 False로
            cnt += 1
            is_turned = False
        # 이동할 위치에 이동 표시를 해주고
        graph[ny][nx] = 1
        # 현재 값을 이동할 위치로 갱신
        y, x = ny, nx
    # 만약 위 조건을 만족 못했는데 이전에 turn을 한 것이라면 더이상 이동할 수 없으므로 중단
    elif is_turned:
        break
    # 첫 번째 조건을 만족 못했다면 idx 값을 1 증가해서 회전을 시도, is_turned도 True로
    elif not is_turned:
        idx += 1
        is_turned = True
# 위 반복을 마치면 cnt 값을 출력
print(cnt)
```
* 32,412 KB
* 40 ms