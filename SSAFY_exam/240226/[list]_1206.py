'''
1206 .
[S/W 문제해결 기본] 1일차 - View

1차원 배열에서 주어진 수는 건물의 높이
좌우로 2칸 이상 시야가 확보될 때 조망권이 확보된다고 한다.
전체 배열에서 조망권이 확보된 세대수의 개수는

가로 길이는 항상 1000이하로 주어진다.
맨 왼쪽 두 칸과 맨 오른쪽 두 칸에는 건물이 지어지지 않는다. (예시에서 빨간색 땅 부분)
각 빌딩의 높이는 최대 255이다.

총 10개의 테스트케이스가 주어진다.
각 테스트케이스의 첫 번째 줄에는 건물의 개수 N이 주어진다. (4 ≤ N ≤ 1000)
그 다음 줄에는 N개의 건물의 높이가 주어진다. (0 ≤ 각 건물의 높이 ≤ 255)
맨 왼쪽 두 칸과 맨 오른쪽 두 칸에 있는 건물은 항상 높이가 0이다. (예시에서 빨간색 땅 부분)
'''


def f(n):
    # 조망권이 확보된 세대의 수 sight
    sight = 0
    # 조망권을 검사할 세대의 수는 좌우측 2칸씩을 제외한 범위
    for i in range(2, n - 2):
        # 검사할 세대의 좌우 2칸씩의 세대의 인덱스를 저장할 nb
        nb = [0] * 4
        # 좌우 총 4개의 세대를 nb에 배정
        for j in range(2):
            nb[2*j], nb[2*j+1] = i-(j+1), i+(j+1)
        # 인접한 4개 세대 중 최고로 높은 건물의 높이를 저장할 nmb
        nmb = 0
        # 좌우 세대 중, nmb 보다 큰 값이 있으면 nmb 를 갱신
        for k in nb:
            if nmb < b[k]:
                nmb = b[k]
        # 중간 빌딩이 양 옆 4개의 빌딩보다 높으면 양 옆 중 최고 빌딩의 높이보다 높은만큼 조망권 확보
        if b[i] > nmb:
            sight += b[i]-nmb
    return sight


for tc in range(1, 11):
    N = int(input())
    b = list(map(int, input().split()))

    print(f'#{tc} {f(N)}')
